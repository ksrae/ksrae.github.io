---
title: "Lesson 11-Implement"
date: 2019-11-29 16:24:00 +0900
comments: true
categories: rust
tags: [lesson-rust]
---

[한국어(Korean) Page](https://velog.io/@ksrae/%EA%B0%95%EC%A2%8C11-%EA%B5%AC%EC%A1%B0%EC%B2%B4%EC%9D%98-%ED%99%95%EC%9E%A5-Implement)
<br/>

Applying the `impl` keyword to a struct in Rust allows you to add methods to it. This provides functionality similar to class structures, making it a very useful feature.

```rust
struct User {
  first: String,
  last: String,
  age: u32
}

impl User {
  fn full_name (&self) -> String {
    format!("{} {}", self.first, self.last)
  }
}
```

To use this feature, a struct must first be defined. Each function within the `impl` block must have `&self` as its first argument. This argument provides access to the struct's data.

## Usage and Flexibility

The `impl` block can contain multiple functions and can be declared multiple times for the same struct. This allows for modular organization of your code.

```rust
impl User {
  fn full_name (&self) -> String {
    format!("{} {}", self.first, self.last)
  }
  fn all(&self) -> String {
    format!("{} {} {}", self.first, self.last, self.age)
  }
}

// Alternatively
impl User {
  fn full_name (&self) -> String {
    format!("{} {}", self.first, self.last)
  }
}

impl User {
  fn all(&self) -> String {
    format!("{} {} {}", self.first, self.last, self.age)
  }
}
```

## Restrictions: No Duplicate Function Definitions

It is not permitted to define functions with the same name within the same `impl` block or across multiple `impl` blocks for the same struct. This includes attempting to overload functions by changing the parameter list.

```rust
impl User {
  fn full_name (&self) -> String {
    format!("{} {}", self.first, self.last)
  }
}

impl User {
  fn full_name (&self) -> String {
    format!("{} {}", self.last, self.first)
  }
}

// Result
   |
8  | /   fn full_name (&self) -> String {
9  | |     format!("{} {}", self.first, self.last)
10 | |   }
   | |___^ duplicate definitions for `full_name`
...
14 | /   fn full_name (&self, n: i32) -> String {
15 | |     format!("{} {}", self.last, self.first)
16 | |   }
   | |___- other definition for `full_name`
```

Attempting to redefine a function name, even with different parameter types, will result in a compilation error due to the duplicate definition.

```rust
impl User {
  fn full_name (&self) -> String {
    format!("{} {}", self.first, self.last)
  }
}

impl User {
  fn full_name (&self, n: i32) -> String {
    format!("{} {}", self.last, self.first)
  }
}

// Result
   |
8  | /   fn full_name (&self) -> String {
9  | |     format!("{} {}", self.first, self.last)
10 | |   }
   | |___^ duplicate definitions for `full_name`
...
14 | /   fn full_name (&self, n: i32) -> String {
15 | |     format!("{} {}", self.last, self.first)
16 | |   }
   | |___- other definition for `full_name`
```

## Additional Arguments

Methods within `impl` blocks can accept arguments in addition to `&self`. To pass values to these arguments, you call the function as you would call any other method. The `&self` argument is implicitly passed.

```rust
impl User {
  fn is_older (&self, age:u32) -> bool {
    self.age > age
  }
}

fn main() {
    let user = User { first: "John".to_string(), last: "Doe".to_string(), age: 30 };
    println!("{}", user.is_older(20)); // Correct way to call is_older
}
```